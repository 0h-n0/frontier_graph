## やったこと

### 方針

- まず部分グラフを列挙して各 node に layer を当てはめていくという方針はそのまま。
- 部分グラフの列挙は自分でも単純な物を書いたが frontier 法の方が早いと思う
- 各 node に layer を当てはめていく部分で思いついた不要な探索を無くした。
  - 各 node に input と output のサイズを割り当てていく感じ(kernel size と stride の組み合わせからあり得るものに限定する)
  - `output channels`はグラフの有効/無効に関係なささそうだったのでとりあえず無視
  - 縦横は独立して考えて良さそうだったので、縦横が同じ size になるもののみを探索する
  - グラブの形状から同じ size になることがわかる node(input の size は同じ、concat への入力は同じ size、など)は縮約しておく
  - 各骨格ごとに有効のなレイヤーのレイヤーの当てはめ方を列挙してその中から良さげなものを一つ選ぶ

### 実装

- とりあえず`python_examples/network_generator`に実装した分を入れています。
- 出来たものに dry run してエラーにならないかは確認しています。

### 未実装の部分

- `output channels`を決める部分。
  - 後から自由に決められるのもあって未実装。
- `flatten`
  - 現時点では output まで全て 3 次元で計算しています。
  - あらかじめ output が 3 次元になる node と 1 次元になる node を決めておいてから計算するのがいい気がしていますがそんなに大変ではないと思っています。
  - とりあえず 3 次元で計算しておいて後から変えるでもいいかもしれないです。

### 懸念点など

- グラフのサイズや構造次第では面白みのない network(size がほとんど変わらない、input から output まで一本道など)ばかり列挙されるかもしれない。
- グラフのサイズによっては現実的な時間で見つけられない(今のところ、愚直に探索していく感じで多項式時間で終わるアルゴリズムではない)。

=> 与えられるグラフのサイズ(頂点数、変数)、避けたいネットワーク構造など、あれば知りたい。

### テスト実行

- `python_examples/network_generator/run_all.py`を叩くと骨格の作成から有効なネットワークの列挙まで走り、`test_outputs`下に生成されたネットワークを可視化して保存します。
  - 可視化のために`dry run`してますがしなければもう少し速いとは思います。
