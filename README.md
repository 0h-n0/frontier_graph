### 全体的な処理の概要

```
元となるグラフを決める
骨格を決める
各頂点の出力の次元を矛盾がないように定める
各頂点の出力のサイズを矛盾がないように定める
各頂点のoutput_channelsを定める
上記で決めた出力サイズ、次元、output_channelsに基づいて各頂点にlayerを割り振る
```

- 使い方の１つの例として`run_all.py`に`list_networks`を用意しています(詳細は docstring を参照)。

### 骨格を決める(`FrameGenerator.sample_graph()`)

大まかにいうと、

1. 上から順に見ていって使う辺を決めていく
2. 出力の頂点で使われていないものがあったら逆順につないでいく。

という動作をします。この際、各頂点からの出力の辺を選ぶ方法は、出力の辺の数が$k$だとすると$2^k - 1$通りありますが、これらから等確率で選ぶという実装になっています  
concat ばかりになってしまうなどの理由でグラフの形状をコントロールしたい場合は、「等確率」というのを変更する必要があります。

### 各頂点の出力の次元を定める(`OutputSizeSearcher.sample_output_dimensions()`)

いくつか(引数の `n_seed_nodes` で与える)出力の次元が 1 になる頂点を決めて、それらから到達可能な頂点たちの出力の次元は 1、それ以外の頂点の出力の次元は 4 とします。  
`n_seed_nodes`はグラフの大きさなどによって適切に変更する必要があると思われます。

### 各頂点の出力サイズを定める(`OutputSizeSearcher.sample_valid_output_size()`)

骨格の形状によっては有効な出力サイズを見つけるのが著しく難しかったり、不可能だったりするので、`max_failures`を引数で与えられるようにしています。

### 各頂点に layer を割り振る(`NNModuleGenerator.add_layer()`)

概ね以下のような実装になっています。割り振られる layer の種類を変更したい場合は該当部分を変更する必要があります。

- 入力が複数ある場合
  - 入力の次元が 4 出力の次元が 1 の場合 => concat + flatten
  - 入力の次元が 4 出力の次元が 4 で入力のサイズと出力のサイズが異なる場合 => concat + convolution
  - 入力の次元が 4 出力の次元が 4 で入力のサイズと出力のサイズが等しい場合 => concat
  - 入力の次元が 1 出力の次元が 1 の場合 => concat
- 入力が 1 つの場合
  - 入力の次元が 4 出力の次元が 4 で入力のサイズと出力のサイズが異なる場合 => convolution
  - 入力の次元が 4 出力の次元が 4 で入力のサイズと出力のサイズが等しい場合 => identity or relu をランダムに振る
  - 入力の次元が 1 出力の次元が 1 の場合 => identity or linear をランダムに振る

### その他

- 乱数を使用しているため再現性を確保したければ乱数種の設定が必要となります。
  - 乱数の生成には Python 標準ライブラリの random モジュールを使用しています。
- `OutputSizeSearcher`と`NNModuleGenerator`に同じ`kernel_sizes`や`strides`を与えるように呼び出し側が気を付けないといけない実装になってしまっています。
